/* This file provide root store defaults for all CDCR Mobile Applications */
import Vue from "vue";
import {
  set as setItem,
  get as getItem,
  del as removeItem,
  clear as removeAll,
  keys as getKeys,
} from "idb-keyval"; // https://github.com/jakearchibald/idb-keyval
import { encryptData, decryptData } from "./crypto";
import { modules, getStore, idbStoreObjects } from "./idbStore";

const rootModule = "root";

// ==========================================================
// Helper Functions
// ==========================================================
/**
 * Helper function to set state
 *
 * @param {String} state
 * @param {String} module
 * @param {String} key
 * @param {String} childKey
 * @param {*} value
 */
function _setState(state, module, key, childKey, value) {
  // Use module if provided, otherwise root
  if (module === rootModule) module = null;
  if (module) state = state[module];

  if (key) {
    if (childKey) {
      Vue.set(state[key], childKey, value);
      value = state[key];
    }
    // Set the state at the module
    Vue.set(state, key, value);
  }
}

/**
 * Generic console logger for errors
 *
 * @param {String} functionName
 * @param {*} params
 * @param {Error} error
 */
function _consoleError(functionName, params, error) {
  console.groupCollapsed(
    "%c%s",
    "color: white; background: red; font-size: 12px;",
    `${functionName} - error`,
    "(expand for more)"
  );
  console.log("Function: ", functionName);
  console.log("Params: ", params);
  console.log("Error: ", error);
  console.groupEnd();
}

/**
 * This helper function is required for all VueX Modules
 * to lets us initialize their default state on RESET
 */
function _initialState() {
  return {
    initialized: false, // set true once framework stores are restored from IDB
    loading: 0, // used throughout app during API calls, etc
    loadingSteps: {
      /**
       * "name": "",
       */
    },
    appLocked: false, // app is locked by idle timeout, or manually by user
    idleSecondsLeft: null, // idle counter stored here so various app events can reset
    snackbar: {
      show: false,
      timeout: 6000,
      text: "",
      showClose: true,
      closeText: "Close",
      position: "bottom", // left, right, top, bottom
    },
  };
}

function _getInitialState(rootGetters, module) {
  let init;
  if (module === rootModule) module = null;
  if (rootGetters) {
    init = module
      ? rootGetters[`${module}/initialState`]
      : rootGetters.initialState;
  }
  if (!init) {
    throw new Error(`VueX getter 'initialState' required for ${module}`);
  }
  return init;
}

// ==========================================================
// State
// ==========================================================
const state = { ..._initialState() };

// ==========================================================
// Getters
// ==========================================================
const getters = {
  /**
   * This function comes default with all generated VueX Modules
   * This returns the initial states to set the defaults for a module
   */
  initialState() {
    return _initialState();
  },
};

// ==========================================================
// Mutations - synchronous
// ==========================================================
const mutations = {
  /**
   * This function sets the application snackbar with the following defaults
   * show: Boolean,
   * timeout: Optional, defaults to 6000ms
   * text: String,
   * showClose: Optional, defaults to false,
   * closeText: String,
   * position: Optional, defaults to bottom
   *
   * @param {Object} {show, timeout, text, showClose, closeText, position}
   */
  SET_SNACKBAR(state, { show, timeout, text, showClose, closeText, position }) {
    state.snackbar = { show, timeout, text, showClose, closeText, position };
  },

  /**
   * Increment the main progress loader in the navbar
   * This function takes in the name and description of the loaded item to be pushed onto the stack.
   * This loaded item can then be viewed by clicking the progress loader on the main nav bar.
   *
   * @param {Object} {name, description}
   */
  INCREMENT_LOADING(state, { name, description }) {
    if (name === "" || description === "") {
      throw new Error("INCREMENT_LOADING: name and description required.");
    }
    if (name in state.loadingSteps) {
      throw new Error(
        `INCREMENT_LOADING: No duplicate names allowed. ${name} already exists.`
      );
    }
    state.loading++;
    Vue.set(state.loadingSteps, name, description);
  },

  /**
   * Decrement the main progress loader in the navbar.
   * This function takes in the name of the loaded item to be popped off the stack
   *
   * @param {String} name
   */
  DECREMENT_LOADING(state, name) {
    if (name === "") {
      throw new Error("DECREMENT_LOADING: name required.");
    }

    state.loading--;
    Vue.delete(state.loadingSteps, name);
  },

  /**
   * Generic key value function for setting data
   * The module and key are both optional
   *
   * @param {Object} {module, stateName, key, value}
   */
  SET_STATE(state, { module, key, childKey, value }) {
    _setState(state, module, key, childKey, value);
  },

  /**
   * Generic function to clear state
   * The module and key are both optional
   *
   * @param {Object} {module, key, childKey}
   */
  CLEAR_STATE(state, { module, key, childKey }) {
    _setState(state, module, key, childKey, null);
  },
};
// ==========================================================
// Actions - asynchronous
// ==========================================================
const actions = {
  /**
   * *This is an action only because we need access to getters*
   * This action resets the current root store or the store module passed in
   *
   * @param {String} module - An optional module, otherwise defaults to root store
   */
  RESET({ rootGetters, commit }, module) {
    // Get the intialState using the getter
    if (module === rootModule) module = null;
    if (!module) return; // TODO: we don't want to wipe out loading, appLocked, etc
    const s = _getInitialState(rootGetters, module);

    Object.keys(s).forEach((key) => {
      const value = s[key];
      // Commit the state with the module key and value
      commit("SET_STATE", { module, key, value });
    });

    // TODO: clear state for any objects not in initialState
  },

  /**
   * Persists the state to offline storage
   *
   * @param {Object} {module, key, value}
   */
  persistState({ commit }, { module, key, value }) {
    return new Promise((resolve, reject) => {
      // console.log(
      //   `PERSISTING to IDB: ${
      //     module ? key + "@" + module : key
      //   } with`,
      //   value
      // );
      if (module === rootModule) module = null;
      const idbStore = getStore(module);
      const idbKey = key;
      // FIXME: Replace the password and salt
      commit("SET_STATE", { module, key, value });
      encryptData(value, "password", "salt")
        .then((idbValue) => {
          return setItem(idbKey, idbValue, idbStore);
        })
        .then(() => {
          resolve(true);
        })
        .catch((err) => {
          _consoleError("persistState", arguments[1], err);
          reject(err);
        });
    });
  },

  /**
   * Clears the state from offline storage.
   * This function only knows about the keys that were persisted to idb
   * Any other keys not persisted will not be removed from VueX.
   *
   * @param {Object} {module, key}
   */
  clearState({ commit }, { module, key }) {
    return new Promise((resolve, reject) => {
      // console.log(
      //   `REMOVING from IDB: ${module ? key + "@" + module : key}`
      // );
      if (module === rootModule) module = null;
      const idbStore = getStore(module);
      const idbKey = key;
      commit("CLEAR_STATE", { module, key });
      removeItem(idbKey, idbStore)
        .then(() => {
          resolve(true);
        })
        .catch((err) => {
          _consoleError("clearState", arguments[1], err);
          reject(err);
        });
    });
  },

  /**
   * Loads the state from offline storage for a specific key in the given store
   *
   * @param {String} {module, key}
   */
  restoreState({ commit }, { module, key }) {
    return new Promise((resolve, reject) => {
      if (module === rootModule) module = null;
      const idbStore = getStore(module);
      const idbKey = key;
      getItem(idbKey, idbStore)
        .then((value) => {
          // FIXME: Replace the password and salt
          return decryptData(value, "password", "salt");
        })
        .then((value) => {
          commit("SET_STATE", { module, key, value });
          resolve(value);
        })
        .catch((err) => {
          _consoleError("restoreState", arguments[1], err);
          reject(err);
        });
    });
  },

  /**
   * Loads the state module from offline storage returning all values in the given store
   *
   * @param {String} module
   */
  restoreStateAll({ commit, dispatch }, module) {
    return new Promise((resolve, reject) => {
      if (module === rootModule) module = null;
      let name = module ?? rootModule;
      console.log(`Restoring module ${name}`);
      commit("INCREMENT_LOADING", { name, description: `Restoring ${name}` });
      dispatch("RESET", module)
        .then(() => {
          const idbStore = getStore(module);
          return getKeys(idbStore);
        })
        .then((keys) => {
          let promises = [];
          keys.forEach((key) => {
            promises.push(dispatch("restoreState", { module, key }));
          });
          return Promise.all(promises);
        })
        .then(() => {
          resolve(true);
        })
        .catch((err) => {
          _consoleError("restoreStateAll", arguments[1], err);
          reject(err);
        })
        .finally(() => {
          commit("DECREMENT_LOADING", name);
        });
    });
  },

  /**
   * Loads root, user and all other modules from offline storage
   */
  restoreAll({ rootGetters, commit, dispatch }) {
    return new Promise((resolve, reject) => {
      console.groupCollapsed("Restoring All Modules");
      let promises = [];
      Object.keys(idbStoreObjects).forEach((module) => {
        const s = _getInitialState(rootGetters, module);
        if (s && s.lazyload) {
          // if module is lazyload, only reset
          promises.push(dispatch("RESET", module));
        } else {
          promises.push(dispatch("restoreStateAll", module));
        }
      });
      Promise.all(promises)
        .then((response) => {
          commit("SET_STATE", { key: "initialized", value: true });
          console.log("Loaded 👍");
          console.groupEnd();
          resolve(response);
        })
        .catch((err) => {
          _consoleError("restoreAll", arguments[1], err);
          console.groupEnd();
          reject(err);
        });
    });
  },

  /**
   * This function returns a single record from idb using the key
   * ! This may become OBSOLETE when IDB is encrypted
   * ? An idea may be to hash the keys when storing them in iDB
   * ? that way we can still query for them and decrypt the response object.
   *
   * @param {Object} { module, key }
   */
  getRecord(context, { module, key }) {
    return new Promise((resolve, reject) => {
      if (module === rootModule) module = null;
      console.log("getRecordCount: ", arguments[1]);
      const idbStore = getStore(module);
      getItem(key, idbStore)
        .then((item) => {
          console.log("Record: ", item);
          resolve(item);
        })
        .catch((err) => {
          _consoleError("getRecord", arguments[1], err);
          reject(err);
        });
    });
  },

  /**
   * This function takes in an optional module to delete a single VueX store.
   * Not passing a module will default it to "root".
   *
   * @param {String} module
   */
  deleteAll({ dispatch }, module) {
    return new Promise((resolve, reject) => {
      if (module === rootModule) module = null;
      dispatch("RESET", module);
      const idbStore = getStore(module);
      removeAll(idbStore)
        .then(() => {
          resolve(true);
        })
        .catch((err) => {
          _consoleError("deleteAll", arguments[1], err);
          reject(err);
        });
    });
  },
};

export { state, getters, mutations, actions, modules };
